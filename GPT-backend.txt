Backend Architecture and Data Models
The backend will use Node.js/Express with MongoDB/Mongoose for data storage, JWT for authentication, and AWS S3 for file storage. Below are the key data models (Mongoose schemas) and their fields, followed by the main API routes and controllers needed.
User Model: Represents all users (admin, researchers, committee members, reviewers).
Proposal Model: Represents a research proposal with its metadata, content forms, status, and relationships.
ProposalVersion Model: Tracks each saved version of a proposal’s content and related AI report.
Comment/Suggestion Model: Stores review comments, suggestions, and clarification requests (threaded).
ChatMessage Model: Stores real-time chat messages between collaborators on a proposal.
Report Model: Stores reviewer/committee reports (content and PDF link).
(Optional) Notification/Activity Model: Logs actions or notifications (for admin dashboard or in-app notifications).
Each model uses standard fields (_id, timestamps) plus the fields below:
User Model
fullName (String) – Full name of the user.
email (String, unique) – Login email address.
password (String) – Hashed password.
phone (String) – Contact number (optional).
designation (String) – e.g. Research Scholar, Professor, Scientist.
organizationName (String) – Name of the institution/organization.
organizationType (String) – e.g. “Indian Academic/Research Institution”, “Private Sector”, etc.
country (String)
addressLine1 (String) – Street address or P.O. Box.
addressLine2 (String) – Additional address info (optional).
city (String)
state (String)
expertiseDomains (Array of Strings) – Comma-separated expertise areas.
roles (Array of Strings) – Roles assigned, e.g. ["USER"], ["ADMIN"], ["CMPDI_MEMBER"], ["TSSRC_MEMBER"], ["SSRC_MEMBER"], ["REVIEWER"], etc. (A user can have multiple roles.)
createdAt, updatedAt (Date) – Timestamps.
All fields except addressLine2, phone, etc. can be required. The email should be unique and used for JWT auth. The roles field controls access (admin vs. normal user vs. committee).
Proposal Model
title (String) – Project title (max 150 chars).
fundingMethod (String, enum) – “S&T of MoC” or “R&D of CIL”.
principalAgency (String) – Principal implementing agency name.
subAgencies (Array of Strings) – Sub-implementing agencies (if any).
projectLeader (String) – Name of the project leader.
projectCoordinator (String) – Name of the project coordinator.
durationMonths (Number) – Project duration in months.
outlayLakhs (Number) – Project outlay in lakhs.
status (String, enum) – Current status, e.g. “DRAFT”, “SUBMITTED”, “CMPDI_REVIEW”, “CMPDI_APPROVED”, “TSSRC_REVIEW”, “TSSRC_APPROVED”, “SSRC_REVIEW”, “ACCEPTED”, “ONGOING”, “REJECTED”, etc.
currentVersion (Number) – Latest committed version number.
createdBy (ObjectId → User) – PI who created the proposal.
coInvestigators (Array of ObjectId → User) – Invited CI collaborators.
collaborators (Array of ObjectId → User) – All users (PI, CIs, committee/reviewers) with edit/suggestion access.
assignedReviewers (Array of ObjectId → User) – Experts or reviewers assigned for domain review.
versions (Array of Objects or Refs) – Version history (see ProposalVersion below). Could be embedded subdocuments or referenced models.
forms (Object) – Stores content of each form in JSON (Plate.js) format:
formI, formIA, formIX, formX, formXI, formXII (each could be a Mixed/JSON field).
These fields hold the latest content or draft content.
supportingDocs (Array of Strings) – URLs of uploaded PDF forms (if user uploads a filled form PDF).
chatMessages (Array of ObjectId → ChatMessage) – Related chat messages.
comments (Array of ObjectId → Comment) – Related review comment threads.
reports (Array of ObjectId → Report) – Related reviewer/committee reports.
timeline (Array of Objects) – Records of status changes, each with { status: String, changedBy: ObjectId, timestamp: Date }.
createdAt, updatedAt (Date).
This schema links proposals to users (PI, CI, reviewers) and tracks content and status. All six form contents are stored within the proposal (as JSON blobs). Version history is tracked either as embedded subdocuments or via a separate ProposalVersion model.
ProposalVersion Model
proposalId (ObjectId → Proposal) – Reference to parent proposal.
versionNumber (Number) – E.g. 1, 2, ... for each full submission; decimals for drafts (e.g. 1.1).
commitMessage (String) – Provided by PI at version commit.
forms (Object) – Snapshot of all form contents (same structure as in Proposal: formI, formIA, etc in JSON).
aiReportUrl (String) – S3 URL of the generated AI evaluation PDF for this version.
createdBy (ObjectId → User) – Who created this version (PI).
createdAt (Date).
This model (or embedded array in Proposal) stores each committed version separately. Version 1 is the first full submission, then 2, etc. Draft saves can be marked 0.1, 1.1, etc. Each version includes the plate.js content and link to its AI report.
Comment/Suggestion Model
proposalId (ObjectId → Proposal) – Which proposal it belongs to.
author (ObjectId → User) – Who made the comment (PI, CI, reviewer, committee, or AI system).
content (String) – Comment text or suggestion.
createdAt (Date).
resolved (Boolean) – Whether this thread is resolved.
resolvedBy (ObjectId → User, optional) – Who marked it resolved.
resolvedAt (Date, optional).
parentComment (ObjectId → Comment, optional) – If this is a reply, link to parent comment.
isInline (Boolean) – True if this was an inline (editor) comment vs general.
linePosition (Mixed) – (Optional) Reference to position in document for inline comments (depending on Plate.js format).
This supports threaded comments/suggestions. A top-level comment spawns a conversation; replies reference parentComment. Both resolved threads and open threads are stored. “AI review” comments can also use this model (author = a system user or null).
ChatMessage Model
proposalId (ObjectId → Proposal) – Which proposal chat.
sender (ObjectId → User) – Who sent the message.
message (String) – Chat text.
createdAt (Date).
A simple chat log. All collaborators on a proposal can send/receive these messages. No edits or deletes needed (immutable).
Report Model
proposalId (ObjectId → Proposal) – Related proposal.
author (ObjectId → User) – Committee member or reviewer who wrote it.
content (Mixed) – Plate.js JSON content of the report.
pdfUrl (String) – S3 URL of the generated PDF of the report.
createdAt (Date).
Committee/reviewer reports are written in the editor (Plate.js) and then saved. The content is stored (for version history or editing) and a final PDF is uploaded to S3.
(Optional) Notification/Activity Model
For admin dashboards or notification systems:
userId (ObjectId → User) – Who gets the notification (or who did the action).
proposalId (ObjectId, optional) – Related proposal.
action (String) – Description (e.g. “Proposal Submitted”, “Marked as Resolved”).
details (Mixed) – Extra data (timestamps, comments).
createdAt (Date).
This could log events (for admin to see user actions, or for notifying users of changes). Not strictly required, but helpful for “recent activity” feeds.
API Routes and Controllers
The backend API will be organized by resource/controller. Below is a top-level overview of the main routes (RESTful endpoints) and their purposes. Each route will have a corresponding controller function in Express.
Authentication Routes
POST /auth/register – Register a new normal user (self-signup). Validates input, hashes password, creates User.
POST /auth/login – Authenticate (email/password) and issue a JWT.
POST /auth/logout – (Optional) Invalidate token or handle client-side logout.
GET /auth/me – (Auth required) Get current user profile.
Controllers: AuthController handles registration (normal users only), login (generating JWT), token verification middleware.
User Management Routes
GET /users – [Admin only] List all users or filter by role/status.
POST /users – [Admin only] Create a new user (any role).
GET /users/:userId – [Admin or self] Get a user’s profile.
PATCH /users/:userId – [Admin or self] Update user profile (self can update own name, phone, etc; Admin can also change roles).
DELETE /users/:userId – [Admin only] Delete a user.
POST /users/:userId/role – [Admin only] Assign or change roles (e.g. make user a CMPDI member).
Controllers: UserController with methods for CRUD operations. Password changes should be separate route or included with validation. Role changes only by admin. On update, trigger notifications if needed.
Proposal Routes
GET /proposals – List proposals. Query by: all (admin), by owner (PI’s own), by assignment (CMPDI/TSSRC/SSRC dashboard), or others (reviewer’s assigned proposals). Support filters (status, user role).
POST /proposals – Create a new proposal. Request includes basic info and optionally the first form content. Marks status “DRAFT” and assigns version=0.1. The creating user becomes createdBy.
GET /proposals/:proposalId – View a proposal’s metadata (if user has access).
PUT /proposals/:proposalId – Update proposal info or draft content (forms). Allowed for PI/CI when editing draft. Handles saving forms content to DB.
DELETE /proposals/:proposalId – [Admin or PI] Delete a draft proposal.
POST /proposals/:proposalId/submit – [PI only] Finalize and submit all forms. Triggers: set status “SUBMITTED”, create Version 1 with commit message, call AI (mock) and save AI report URL, notify CMPDI.
GET /proposals/:proposalId/track – (or integrated in detail) Return proposal timeline/status history. Useful for track page.
Controller: ProposalController. It handles creating and updating proposals, changing status, adding collaborators (see below), and returning lists. On submit, it should create a new version (move draft to version 1), update status, and enqueue AI report (or mock).
Collaboration & Versioning Routes
POST /proposals/:proposalId/invite – [PI only] Invite a co-investigator by email. Creates a user if needed or adds existing user’s ID to coInvestigators and collaborators. Sends invitation email.
POST /proposals/:proposalId/add-collaborator – [Restricted] (e.g. admin or CMPDI can add reviewer/committee as collaborator on a proposal).
GET /proposals/:proposalId/versions – List all versions for the proposal (with commit messages and timestamps).
POST /proposals/:proposalId/versions – [PI only] Commit current draft as a new version. Request includes a commitMessage. Increments version, saves all form content in a ProposalVersion entry, generates new AI report (mocked), stores URL. Update currentVersion.
PUT /proposals/:proposalId/versions/:versionNumber/revert – [PI only] Revert to an old version: fetch that version’s content and set it as the current draft (optionally create a new version entry with a revert message).
Real-time Editing (Yjs/Hocuspocus): Setup a Hocuspocus server for collaborative editing. Each proposal has a shared document ID. The backend should allow the editor to fetch the initial content (from the proposal’s current forms) and save changes. Auto-save (every 30s) calls PUT /proposals/:proposalId to update the forms JSON. The submit button triggers the version commit route above.
Controllers: VersionController can handle version listing, creation, and reverting. Note that Yjs synchronization is mostly handled by the Hocuspocus server; however, the backend must integrate saving the latest content to the database (auto-save and manual save routes). The collaborators list is also managed by ProposalController.
Comment & Suggestion Routes
GET /proposals/:proposalId/comments – List all comment threads (open and resolved) for this proposal.
POST /proposals/:proposalId/comments – Add a new comment thread (author, content). Can be called by reviewers, committee, or AI.
POST /comments/:commentId/reply – Reply to an existing comment (adds to the thread).
PUT /comments/:commentId/resolve – Mark a comment thread as resolved (any participant or the thread author).
GET /comments/:commentId – Get full thread (for UI).
Controllers: CommentController. Manages CRUD on comments. Each comment links to a proposal and optionally a parent. Resolution marks resolved=true.
Chat Routes
GET /proposals/:proposalId/chat – Fetch the latest chat messages for a proposal. (Optionally support pagination.)
POST /proposals/:proposalId/chat – Post a new chat message.
Controllers: ChatController. Stores and retrieves chat messages. These are simple and real-time clients can poll or subscribe (if using sockets).
Report Routes
GET /proposals/:proposalId/reports – List all submitted reports (by reviewers/committee) for the proposal.
GET /proposals/:proposalId/reports/:reportId – Download or view a specific report (returns PDF URL or content).
POST /proposals/:proposalId/reports – [Reviewer/Committee only] Submit a new report. Accepts Plate.js JSON content, saves a Report with content, generates PDF (mock or actual), uploads to S3, and saves pdfUrl.
Controllers: ReportController. Manages creation and retrieval of reports. Each report links to a user and proposal.
Approval/Workflow Routes
PUT /proposals/:proposalId/status – [Committee only] Update proposal status (approve/reject) at each stage. For example, CMPDI member approves → set status=CMPDI_APPROVED and assign to TSSRC. If rejecting, set status REJECTED. Include any comments or report linking.
PUT /proposals/:proposalId/assign – [CMPDI/TSSRC] Assign experts or committee members to review this proposal. E.g. attach users to assignedReviewers or collaborators.
POST /proposals/:proposalId/request-clarification – [Committee only] Send a clarification request to the PI (creates a comment or sends email).
Controllers: WorkflowController (or shared in ProposalController). Handles status transitions and sending notifications. Decisions are final as per rules. Emails are sent on status changes or requests (if enabled).
File Upload / AWS S3 Routes
POST /upload/image – Upload an image (signature, seal, embedded image). Uses multer or similar to accept the file, then uploads to S3 “images” bucket. Returns the S3 URL.
POST /upload/document – Upload a supporting document (e.g. PDF of filled form). Stores in S3 “proposal-files” bucket. Returns URL to store in Proposal.supportingDocs.
Controllers: FileController. Uses AWS SDK or multer-s3 to handle file uploads. The frontend calls these when user adds an image or document; the controller saves to S3 and returns a public URL, which the frontend will then insert into the Plate.js content or form fields. The backend replaces any embedded image data in the forms with these S3 URLs when saving the proposal.
Summary of Key Controllers
AuthController – register, login, JWT auth.
UserController – CRUD users, profile updates, role changes.
ProposalController – Create/update proposals, submit, assign collaborators, view/list proposals.
VersionController – Handle version commit, history, revert.
CommentController – Handle suggestion threads, replies, resolve.
ChatController – Handle chat messages.
ReportController – Handle creation and retrieval of reviewer/committee reports.
WorkflowController – Manage status transitions (CMPDI/TSSRC/SSRC approvals/rejections).
FileController – Handle file/image uploads to AWS S3.
Each controller will use Mongoose models to interact with MongoDB and enforce role-based access (e.g. middleware to check if user is CMPDI member, PI, etc.). Authentication middleware (JWT) will protect the routes.
Considerations
Version History: Every time the PI “submits” (or commits a new version), a ProposalVersion is created. Auto-saves may update the current draft but not increment version. We can store draft states as sub-versions (e.g. 1.1) in the main Proposal document or as unsaved in front-end until committed.
Role Checks: Middleware should check roles. For example, only PI can invite CIs or revert versions; only CMPDI members can approve at first stage, etc.
Notifications/Emails: On key actions (submission, status changes, comments), send emails. Backend should have a mail service (optionally disabled).
Collaboration Server: The Yjs/Hocuspocus real-time server runs alongside. The backend just provides the initial document JSON (forms content) to clients and saves updates.
ID Schema: Use human-readable proposal IDs (e.g. sequential or code) in addition to Mongo ObjectId. Could store a proposalCode field (like “PROP-00123”).
Database Relations: References (ObjectId) link users, proposals, etc. Use Mongoose ref to populate data as needed for endpoints.